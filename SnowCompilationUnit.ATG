import java.util.ArrayList;
import java.util.List;
import snow.ast.node.*;
import snow.util.*;

COMPILER SnowCompilationUnit
	public BaseAstNode ast;

	public snow.ast.Token toSnowToken(Token t) {
		return new snow.ast.Token(
			t.pos,
			t.charPos,
			t.col,
			t.line,
			t.val
		);
	}

CHARACTERS
	noQuote = ANY - '"'.
	tab = '\t'.
	cr = '\r'.
	lf = '\n'.
	digit = "0123456789".
	letter = "azertyuiopqsdfghjklmwxcvbnAZERTYUIOPQSDFGHJKLMWXCVBN".

TOKENS
	string = '"' {noQuote} '"'.
	integer = digit {digit}.
	additiveOperator = '+' | '-'.
	multiplicativeOperator = '*' | '/' | '%'.
	shiftOperator = "<<" | ">>".
	equalityOperator = "==" | "!=".
	relationalOperator = '<' | '>' | "<=" | ">=".
	unaryOperator = "++" | "--".
	prefixUnaryOperator = '!' | '~'.
	identifier = letter {letter | digit}.
	fun = "fun".
	def = "def".
	if = "if".
	else = "else".
	class = "class".

COMMENTS
	FROM "//" TO cr lf

IGNORE tab+cr+lf

PRODUCTIONS

	SnowCompilationUnit
			(. BaseAstNode node; .)
		= ExpressionList<out node>
			(. this.ast = node; .)
		.

	ExpressionList<out BaseAstNode node>
			(. BaseAstNode secondNode; .)
		= Expression<out node> {';' Expression<out secondNode> (. node = new ExpressionList(null, null, node, secondNode); .)}
		.

	Expression<out BaseAstNode node>
			(. node = null; .)
		= TupleValue<out node>
		| If<out node>
		| Definition<out node>
		| SnowClass<out node>
		.

	SnowClass<out SnowClass node>
			(. Token firstToken; Identifier id; BaseAstNode body = null; .)
		= class (. firstToken = t; .) Identifier<out id> '{' [ExpressionList<out body>] '}'
			(. node = new SnowClass(toSnowToken(firstToken), toSnowToken(t), id, body); .)
		.

	If<out If node>
			(. Token firstToken; BaseAstNode condition; BaseAstNode ifTrue; BaseAstNode ifFalse = null; .)
		= if (. firstToken = t; .) '(' ExpressionList<out condition> ')' Expression<out ifTrue> [IF(la.kind == _else) else Expression<out ifFalse>]
			(. node = new If(toSnowToken(firstToken), toSnowToken(t), condition, ifTrue, ifFalse); .)
		.

	TupleValue<out BaseAstNode node>
			(. Token firstToken; BaseAstNode right = null; .)
		= LogicalOrValue<out node> (. firstToken = t; .) {',' LogicalOrValue<out right>
			(. node = new Tuple(toSnowToken(firstToken), toSnowToken(t), node, right); .) }
			(. node.doNotReplace(); .)
		.

	Definition<out Definition node>
			(. Token firstToken; Identifier id; BaseAstNode value; BaseAstNode typeExpr = null; .)
		= def (. firstToken = t; .) Identifier<out id> [':' Expression<out typeExpr>] '=' Expression<out value>
			(. node = new Definition(toSnowToken(firstToken), toSnowToken(t), id, value, typeExpr); .)
		.

	LogicalOrValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= LogicalAndValue<out node> {"||" (. operator = t.val; .) LogicalAndValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	LogicalAndValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= BitwiseOrValue<out node> {"&&" (. operator = t.val; .) BitwiseOrValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	BitwiseOrValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= BitwiseXorValue<out node> {'|' (. operator = t.val; .) BitwiseXorValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	BitwiseXorValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= BitwiseAndValue<out node> {'^' (. operator = t.val; .) BitwiseAndValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	BitwiseAndValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= EqualityValue<out node> {'&' (. operator = t.val; .) EqualityValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	EqualityValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= RelationalValue<out node> {equalityOperator (. operator = t.val; .) RelationalValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	RelationalValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= ShiftValue<out node> {relationalOperator (. operator = t.val; .) ShiftValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	ShiftValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= AdditiveValue<out node> {shiftOperator (. operator = t.val; .) AdditiveValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	AdditiveValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= MultiplicativeValue<out node> {additiveOperator (. operator = t.val; .) MultiplicativeValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	MultiplicativeValue<out BaseAstNode node>
			(. String operator; BaseAstNode nextNode; .)
		= PostfixUnaryValue<out node> {multiplicativeOperator (. operator = t.val; .) PostfixUnaryValue<out nextNode>
			(. node = new Binary(null, null, node, nextNode, operator); .) }
		.

	PostfixUnaryValue<out BaseAstNode node>
			(. Token firstToken; .)
		= PrefixUnaryValue<out node> (. firstToken = t; .) {unaryOperator (. node = new Unary(toSnowToken(firstToken), toSnowToken(t), node, t.val, true); .)}
		.

	PrefixUnaryValue<out BaseAstNode node> (. Box<BaseAstNode> boxedNode = new Box<>(null); Unary unaryNode = null; List<PartialUnary> pendingUnaries = new ArrayList<>(); .)
		= {(unaryOperator | prefixUnaryOperator) (. pendingUnaries.add(0, new PartialUnary(null, null, t.val)); .) } AccessValue<out node> (. boxedNode.setValue(node); .)
			(. pendingUnaries.forEach(u -> boxedNode.setValue(new Unary(u.firstToken, u.lastToken, boxedNode.getValue(), u.operator, false))); node = boxedNode.getValue(); .)
		.

	AccessValue<out BaseAstNode node>
			(. Token firstToken; String operator; BaseAstNode nextNode; BaseAstNode arg = null; .)
		= SubExpression<out node> (. firstToken = t; .) {
				('.' (. operator = t.val; .) SubExpression<out nextNode>) (. node = new Binary(null, null, node, nextNode, operator); .)
				| ('[' (. operator = t.val; .) SubExpression<out nextNode> ']') (. node = new Binary(null, null, node, nextNode, operator); .)
				| '(' [ExpressionList<out arg>] ')' (. node = new Call(toSnowToken(firstToken), toSnowToken(t), node, arg); .)
			}
		.

	SubExpression<out BaseAstNode node>
			(. node = null; .)
		= '(' ExpressionList<out node> ')'
		| Literal<out node>
		| Identifier<out node>
		| AnonymousFunction<out node>
		.

	AnonymousFunction<out Function node>
			(. BaseAstNode exprNode = null; Token firstToken; Identifier argName = null; BaseAstNode argType = null; BaseAstNode returnType = null; .)
		= fun (. firstToken = t; .) '(' [Identifier<out argName> [':' Expression<out argType>]] ')' [':' Expression<out returnType>] '{' [Expression<out exprNode>] '}'
			(. node = new Function(toSnowToken(firstToken), toSnowToken(t), null, exprNode, argName, argType, returnType); .)
		.

	Identifier<out Identifier node>
		= identifier
			(. node = new Identifier(toSnowToken(t)); .)
		.

	Literal<out BaseAstNode node>
			(. node = null; .)
		= LiteralInteger<out node>
		| LiteralString<out node>
		.

	LiteralInteger<out LiteralInteger node>
		= integer
			(. node = new LiteralInteger(this.toSnowToken(t)); .)
		.

	LiteralString<out LiteralString node>
		= string
			(. node = new LiteralString(this.toSnowToken(t)); .)
		.

END SnowCompilationUnit.
